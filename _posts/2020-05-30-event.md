---
layout: post
title: "浏览器事件"
subtitle: ""
date: 2020-05-31 00:39:30
author: "Aurora"
tag: javascript
---

## event

事件 是某事发生的信号。所有的 DOM 节点都生成这样的信号（但事件不仅限于 DOM）。

鼠标事件：

- click —— 当鼠标点击一个元素时（触摸屏设备会在点击时生成）。
- contextmenu —— 当鼠标右键点击一个元素时。
- mouseover / mouseout —— 当鼠标指针移入/离开一个元素时。
- mousedown / mouseup —— 当在元素上按下/释放鼠标按钮时。
- mousemove —— 当鼠标移动时。

表单（form）元素事件：

- submit —— 当访问者提交了一个 \<form> 时。
- focus —— 当访问者聚焦于一个元素时，例如聚焦于一个 \<input>。

键盘事件：

- keydown 和 keyup —— 当访问者按下然后松开按键时。

Document 事件：

- DOMContentLoaded —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时。

CSS 事件：

- transitionend —— 当一个 CSS 动画完成时。

### HTML 特性

处理程序可以设置在 HTML 中名为 on\<event> 的特性（attribute）中。

### DOM 属性

我们可以使用 DOM 属性（property）on\<event> 来分配处理程序

> 处理程序总是在 DOM 属性中：HTML 特性只是初始化它的方法之一。
> 因为只有一个 onclick 属性，所以我们无法分配更多事件处理程序。

### addEventListener

上述分配处理程序的方式的根本问题是 —— 我们不能为一个事件分配多个处理程序。

Web 标准的开发者很早就了解到了这一点，并提出了一种使用特殊方法 addEventListener 和 removeEventListener 来管理处理程序的替代方法。它们没有这样的问题。

添加处理程序的语法：

```javascript
element.addEventListener(event, handler[, options]);
```

`event`事件名，例如："click"。

`handler`处理程序。

`options`具有以下属性的附加可选对象：

1. once：如果为 true，那么会在被触发后自动删除监听器。
2. capture：事件处理的阶段，我们稍后将在 冒泡和捕获 一章中介绍。由于历史原因，options 也可以是 false/true，它与 {capture: false/true} 相同。
3. passive：如果为 true，那么处理程序将不会 preventDefault()，我们稍后将在 浏览器默认行为 一章中介绍。

要移除处理程序，可以使用 removeEventListener：

```javascript
element.removeEventListener(event, handler[, options]);
```

> 要移除处理程序，我们需要传入与分配的函数**完全相同**的函数。

### 事件对象

浏览器会创建一个 event 对象，将详细信息放入其中，并将其作为参数传递给处理程序。

event 对象的一些属性：

`event.type`事件类型，这里是 "click"。

`event.currentTarget`处理事件的元素。这与 this 相同，除非处理程序是一个箭头函数，或者它的 this 被绑定到了其他东西上，之后我们就可以从 event.currentTarget 获取元素了。
`event.clientX / event.clientY`鼠标事件的指针的窗口相对坐标。

### 对象处理程序：handleEvent

我们不仅可以分配函数，还可以使用 addEventListener 将一个对象分配为事件处理程序。当事件发生时，就会调用该对象的 handleEvent 方法。

handleEvent 方法不必通过自身完成所有的工作。它可以调用其他特定于事件的方法，例如：

```html
<button id="elem">Click me</button>

<script>
  class Menu {
    handleEvent(event) {
      // mousedown -> onMousedown
      let method = "on" + event.type[0].toUpperCase() + event.type.slice(1);
      this[method](event);
    }

    onMousedown() {
      elem.innerHTML = "Mouse button pressed";
    }

    onMouseup() {
      elem.innerHTML += "...and released.";
    }
  }

  let menu = new Menu();
  elem.addEventListener("mousedown", menu);
  elem.addEventListener("mouseup", menu);
</script>
```

现在事件处理程序已经明确地分离了出来，这样更容易进行代码编写和后续维护。

## 冒泡和捕获

### 冒泡

当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。

> 几乎 所有事件都会冒泡。

### event.target

引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过 event.target 访问。

### 停止冒泡

但是任意处理程序都可以决定事件已经被完全处理，并停止冒泡。

用于停止冒泡的方法是 event.stopPropagation()。

> `event.stopImmediatePropagation()`
>
> 如果一个元素在一个事件上有多个处理程序，即使其中一个停止冒泡，其他处理程序仍会执行。
>
> 换句话说，`event.stopPropagation()` 停止向上移动，但是当前元素上的其他处理程序都会继续运行。
>
> 有一个 `event.stopImmediatePropagation()` 方法，可以用于停止冒泡，并阻止当前元素上的处理程序运行。使用该方法之后，其他处理程序就不会被执行。
> **不要在没有需要的情况下停止冒泡！**
